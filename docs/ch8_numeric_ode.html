<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Mathematical Methods for Biology, Part 1 - 8&nbsp; Numeric solutions of ODEs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ch9_linear_pplane.html" rel="next">
<link href="./ch7_1var_ode.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Numeric solutions of ODEs</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Mathematical Methods for Biology, Part 1</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch1_discrete1var.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">One variable in discrete time</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch2_plotting_python.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Plotting in Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch3_discrete_chaos.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Nonlinear discrete-time dynamic models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch4_cobweb_plots.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Graphical analysis of difference equations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch5_discrete_higher.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Discrete models of higher order</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch6_matrix_mult.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Matrix multiplication and population models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch7_1var_ode.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Models with one variable in continuous time</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch8_numeric_ode.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Numeric solutions of ODEs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch9_linear_pplane.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Linear ODEs with two variables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch10_phase_portraits.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Phase portraits in Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch11_lin_oscillations.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Forces and potentials in biological modeling</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch12_fourier.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Fourier series: decomposition by frequency</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#forward-euler-method" id="toc-forward-euler-method" class="nav-link active" data-scroll-target="#forward-euler-method"><span class="toc-section-number">8.0.1</span>  Forward Euler method</a></li>
  <li><a href="#error-in-numeric-solutions" id="toc-error-in-numeric-solutions" class="nav-link" data-scroll-target="#error-in-numeric-solutions"><span class="toc-section-number">8.0.2</span>  Error in numeric solutions</a></li>
  <li><a href="#backward-euler-method" id="toc-backward-euler-method" class="nav-link" data-scroll-target="#backward-euler-method"><span class="toc-section-number">8.0.3</span>  Backward Euler method</a></li>
  <li><a href="#implementation-in-python" id="toc-implementation-in-python" class="nav-link" data-scroll-target="#implementation-in-python"><span class="toc-section-number">8.1</span>  Implementation in Python</a>
  <ul class="collapse">
  <li><a href="#forward-euler" id="toc-forward-euler" class="nav-link" data-scroll-target="#forward-euler"><span class="toc-section-number">8.1.1</span>  Forward Euler</a></li>
  <li><a href="#backward-euler" id="toc-backward-euler" class="nav-link" data-scroll-target="#backward-euler"><span class="toc-section-number">8.1.2</span>  Backward Euler</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Numeric solutions of ODEs</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>Analytic solutions are very useful for a modeler because they allow prediction of the variable of interest at any time in the future. However, for many differential equations they are not easy to find, and for many others they simply cannot be written down in a symbolic form. Instead, one can use a numeric approach, which does not require an exact formula for the solution. The idea is to start at a given initial value (e.g.&nbsp;<span class="math inline">\(x(0)\)</span>) and use the derivative from the ODE (e.g.&nbsp;<span class="math inline">\(dx/dt\)</span>) as the rate of change of the solution (e.g.&nbsp;<span class="math inline">\(x(t)\)</span>) to calculate the change or increment for the solution over a time step. Essentially, this means replacing the continuous change of the derivative with a discrete time step, thus converting the differential equation into a difference equation and then solving it. The solution of the difference equation is not the same as the solution of the ODE, so <em>numeric solutions</em> of ODEs are always approximate. I will use the notation <span class="math inline">\(\hat x(t)\)</span> to denote the numeric solution to distinguish it from the exact solution <span class="math inline">\(x(t)\)</span>. The fundamental difference between them is that <span class="math inline">\(\hat x(t)\)</span> is not a formula that can be evaluated at any point in time, but instead is a sequence of numbers calculated every time step, which hopefully are close to the exact solution <span class="math inline">\(x(t)\)</span>.</p>
<section id="forward-euler-method" class="level3" data-number="8.0.1">
<h3 data-number="8.0.1" class="anchored" data-anchor-id="forward-euler-method"><span class="header-section-number">8.0.1</span> Forward Euler method</h3>
<p>Let us introduce all the players: first, we need to pick the time step <span class="math inline">\(\Delta t\)</span>, which is the length of time between successive values of <span class="math inline">\(\hat x\)</span>. In the difference equation notation one can use <span class="math inline">\(\hat x_i\)</span> to mean <span class="math inline">\(\hat x(i\Delta t)\)</span>, the value of the numeric solution after <span class="math inline">\(i\)</span> time steps. Then we need to calculate the derivative, or the rate of change at a particular point in time. For any first-order ODE of the form</p>
<p><span class="math display">\[
\frac{d x} {dt} = \dot x = f(x,t)
\]</span></p>
<p>the rate of change depends (potentially) on the values of <span class="math inline">\(x\)</span> and <span class="math inline">\(t\)</span>. This rate of change based on the numeric solution after <span class="math inline">\(i\)</span> time steps is <span class="math inline">\(f(\hat x(i\Delta t), i\Delta t) = f(\hat x_i, t_i)\)</span>. Finally, to calculate the change of the dependent variable we need to multiply the rate of change by the time step. This should make sense in a practical context: if you drive for two hours (time step) at 60 miles per hour (rate of change), the total distance (increment) is <span class="math inline">\(2*60=120\)</span> miles. By the same token, we can write down how to calculate the next value of the numeric solution <span class="math inline">\(y_{i+1}\)</span> based on the previous one:</p>
<p><span class="math display">\[
\hat x_{i+1} = \hat x_i + \Delta t f(\hat x_i, t_i)
\label{eq:ch15_FE}
\]</span></p>
<p>This method of computing a numeric solution of an ODE is called the <em>Forward Euler method</em>, after the famous mathematician who first came up with it. It is called a forward method because it uses the value of the dependent variable and its derivative at time step <span class="math inline">\(i\)</span> to predict the value at the next time step <span class="math inline">\(i+1\)</span>. The method is <em>iterative</em>, so it needs to be repeated in order to calculate a set of values of the approximate solution <span class="math inline">\(y(t)\)</span>. Here are a couple of simple examples of computing numeric solution using FE:</p>
<p><strong>Example.</strong> Let us numerically solve the ODE <span class="math inline">\(\dot x = -0.1\)</span> using the Forward Euler method. This means the defining function in the formulation of FE above is <span class="math inline">\(f(x,t)=-0.1\)</span>. We can calculate the numeric solution for a couple of steps and compare the values with the exact solution, since we now know that it is <span class="math inline">\(x(t) = x_0 -0.1t\)</span>. Let us pick the time step <span class="math inline">\(\Delta t = 0.2\)</span> and begin with the initial value <span class="math inline">\(x(0)=1\)</span>. Here are the first three steps using the FE method:</p>
<p><span class="math display">\[
\begin{aligned}
\hat x(0.2) &amp;=&amp; \hat x(0) + \Delta t f(\hat x(0)) = 1 + 0.2 \times (-0.1) &amp;=&amp; 0.98 \\
\hat x(0.4) &amp;=&amp; \hat x(0.2) + \Delta t f(\hat x0.2)) = 0.98+ 0.2 \times (-0.1) &amp;=&amp; 0.96 \\
\hat x(0.6) &amp;=&amp; \hat x(0.4) + \Delta t f(\hat x(0.4)) = 0.96+ 0.2\times (-0.1) &amp;=&amp;0.94
\end{aligned}
\]</span></p>
<p>Since the rate of change in this ODE is constant, the solution declines by the same amount every time step. In this case, the numeric solution is actually exact and perfectly matches the analytic solution.</p>
<p><strong>Example.</strong> Let us numerically solve the ODE <span class="math inline">\(\dot x = -0.1x\)</span> using the Forward Euler method. This means the defining function in the formulation of FE above is <span class="math inline">\(f(x,t)=-0.1x\)</span>. We can calculate the numeric solution for a couple of steps and compare the values with the exact solution, since we now know that it is <span class="math inline">\(x(t) = x_0 e^{-0.1t}\)</span>. Let us pick the time step <span class="math inline">\(\Delta t = 0.2\)</span> and begin with the initial value <span class="math inline">\(x(0)=100\)</span>. Here are the first three steps using the FE method:</p>
<p><span class="math display">\[
\begin{aligned}
\hat x(0.2) &amp;=&amp; \hat x(0) + \Delta t f(\hat x(0)) = 100 + 0.2\times (-0.1*100) &amp;=&amp; 98 \\
\hat x(0.4) &amp;=&amp; \hat x(0.2) + \Delta t f(\hat x(0.2)) = 98+ 0.2\times (-0.1*98) &amp;=&amp; 96.04 \\
\hat x(0.6) &amp;=&amp; \hat x(0.4) + \Delta t f(\hat x(0.4)) = 96.04+ 0.2\times (-0.1*96.04) &amp;=&amp; \approx 94.12
\end{aligned}
\]</span></p>
<p>In this case, the derivative is not constant and the numeric solution is not exact. The error in the numeric solution grows with time, which may be problematic. We will further investigate how to implement the computation of numeric solutions using R in the next section.</p>
</section>
<section id="error-in-numeric-solutions" class="level3" data-number="8.0.2">
<h3 data-number="8.0.2" class="anchored" data-anchor-id="error-in-numeric-solutions"><span class="header-section-number">8.0.2</span> Error in numeric solutions</h3>
<p>One of the main concerns of numerical analysis is to minimize the difference between the exact solution and the numeric solution, which is known as the <em>error</em>. There are at least two distinct sources of error in numeric solutions: a) <em>roundoff error</em> and b) <em>truncation error</em>. Roundoff error is caused by computers representing real numbers by a finite string of bits on a computer using what is known as a <em>floating point</em> representation. In many programming languages variables storing real numbers can be single or double precision, which typically support 24 and 53 significant binary digits, respectively. Any arithmetic operation involving floating point numbers is only approximate, with an error that depends on the way the numbers are stored in the memory. Truncation error is caused by approximations inherent in numeric algorithms. The most common class of numeric approximations for ODEs is known as <em>finite difference</em> methods, and Forward Euler is a very simple representative of that class. As the name suggests, these methods use difference equations to approximate a differential equation. There is inevitably a truncation error in such methods because they use a more or less clever scheme to approximate the instantaneous rate of change in an ODE, which can be thought as a truncation of the Taylor series after certain term.</p>
<p>A modeler has different controls over the roundoff error and truncation error. The first can be minimized by using more memory to store the numbers, e.g.&nbsp;by using double precision format for the variables. Further, there are techniques for minimizing the so-called loss of significance that occurs in certain arithmetic operations, like subtraction of two similar numbers. We will leave these considerations to numerical analysts <span class="citation" data-cites="press_numerical_2007">(<a href="references.html#ref-press_numerical_2007" role="doc-biblioref"><strong>press_numerical_2007?</strong></a>)</span>; for the most part, roundoff error is not a significant issue on modern computers. Truncation error, however, is much more within our control, because it depends on the choice of the numerical algorithm. One can decrease the error in the case of finite difference methods by choosing smaller time steps, or by choosing an algorithm with a higher <em>order of accuracy</em>.</p>
<p>Returning specifically to the Forward Euler method, it is called a <em>first-order method</em> because the total error of the solution (after some number of time steps) depends linearly on the time step <span class="math inline">\(\Delta t\)</span>. One can show this by using the Taylor expansion of the solution <span class="math inline">\(\hat x(t)\)</span> to derive the forward Euler method, with <span class="math inline">\(\tau(\Delta t)\)</span> representing the truncation error after one time step:</p>
<p><span class="math display">\[
\hat x(t+\Delta t) = \hat x(t) +  \Delta t \frac{d\hat x(t)}{dt} + \tau(\Delta t)
\]</span></p>
<p>As you might have learned in calculus, the error remaining after the linear term in the Taylor series is proportional to the the square of the small deviation <span class="math inline">\(\Delta t\)</span>. This only describes the error after 1 time step, but since the errors accumulate every time step, the total error after <span class="math inline">\(n\)</span> time steps accumulates <span class="math inline">\(n \tau(\Delta t)\)</span>. As we saw in the implementation above, for a given length of time, <span class="math inline">\(n\)</span> is inversely proportional to <span class="math inline">\(\Delta t\)</span>. Therefore, the total error is proportional to the <span class="math inline">\(\Delta t\)</span> and so FE is a first-order method.</p>
<p>The exercise above shows that new errors in FE method accumulate in proportion with the time step. The next question is, what happens to these errors over time? Do they grow or dissipate with more iterations? This is known as the stability of a numerical method, and unlike the above question about the order of accuracy, the answer depends on the particular ODE that one needs to solve. Below I show an example of error analysis for a linear ODE:</p>
<div class="callout-tip callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Error in the FE scheme
</div>
</div>
<div class="callout-body-container callout-body">
<p>To numerically solve the equation <span class="math inline">\(\dot x = ax\)</span>, we substitute the function <span class="math inline">\(ax\)</span> for the function <span class="math inline">\(f(x,t)\)</span>, and obtain the FE approximation for this particular ODE:</p>
<p><span class="math display">\[
\hat x_{i+1} = \hat x_i + \Delta t a \hat x_i = (1+a\Delta t) \hat x_i
\]</span></p>
<p>The big question is what happens to the truncation error: does it grow or decay? To investigate this question, let us denote the error at time <span class="math inline">\(t_i\)</span> , that is the difference between the true solution <span class="math inline">\(x(t_i)\)</span> and the approximate solution <span class="math inline">\(\hat x(t_i)\)</span>, by <span class="math inline">\(\epsilon_i\)</span>. It follows that <span class="math inline">\(\hat x_i = x_i + \epsilon_i\)</span>. Then we can wrote the following difference equations involving the error:</p>
<p><span class="math display">\[
\hat x_{i+1} = x_{i+1} + \epsilon_{i+1} = (x_i + \epsilon_i) (1+a\Delta t)  = x_i (1+a\Delta t) + \epsilon_i(1+a\Delta t)
\]</span></p>
<p>Let us set aside the terms in the equation that involve <span class="math inline">\(x\)</span> (since it is just the equation for forward Euler). The remaining difference equation for <span class="math inline">\(\epsilon\)</span> describes the change in the error:</p>
<p><span class="math display">\[
\epsilon_{i+1} = \epsilon_i(1+a\Delta t)
\]</span></p>
<p>This states that the error in this numeric solution is repeatedly multiplied by the constant <span class="math inline">\((1+a\Delta t)\)</span>. As we saw in section [sec:math14], this linear difference equation has an exponential solution <span class="math inline">\(\epsilon_n = (1+a\Delta t)^n \epsilon_0\)</span>, which decays to 0 if <span class="math inline">\(|1+a\Delta t| &lt; 1\)</span> or grows without bound if <span class="math inline">\(|1+a\Delta t| &gt; 1\)</span>. The first inequality is called the stability condition for the FE scheme, since it guarantees that the old errors decay over time. Since <span class="math inline">\(\Delta t &gt;0\)</span>, the only way that the left hand side can be less than 1 is if <span class="math inline">\(a&lt;0\)</span>. Therefore, the condition for stability of the FE method for a linear ODE: <span class="math display">\[
|1 + a\Delta t| &lt; 1 \Rightarrow \Delta t &lt; -2/a
\]</span></p>
<p>Thus, if <span class="math inline">\(a&gt;0\)</span>, the errors will eventually overwhelm the solution. If <span class="math inline">\(a&lt;0\)</span>, if the time step is small enough (less than <span class="math inline">\(-2/a\)</span>) then FE is stable.</p>
</div>
</div>
<p>Generally speaking, however, Forward Euler is about the worst method to use for practical numeric solutions of ODEs, due to its low accuracy and to its lack of stability under certain conditions.</p>
</section>
<section id="backward-euler-method" class="level3" data-number="8.0.3">
<h3 data-number="8.0.3" class="anchored" data-anchor-id="backward-euler-method"><span class="header-section-number">8.0.3</span> Backward Euler method</h3>
<p>More sophisticated numeric methods generally offer better stability than Forward Euler. For instance, there is a class of methods called <em>implicit</em> schemes which rely on evaluating the value of the derivative of <span class="math inline">\(x\)</span> at a future time point. This may seem impossible, since we do not yet have the value of the dependent variable <span class="math inline">\(x\)</span> in the future, only in the present. In fact, we can set up an algebraic relationship between the present value of <span class="math inline">\(x\)</span>, the future value of <span class="math inline">\(x\)</span>, and the derivative of <span class="math inline">\(x\)</span> in the future. Then, depending on the form of the defining function <span class="math inline">\(f(x)\)</span>, we may solve this relationship for the value of <span class="math inline">\(x\)</span> at the future time.</p>
<p>To make the idea of implicit methods concrete, we will introduce a simple method called the Backward Euler. As suggested by the name, this method is essentially similar to the Forward Euler, but with the future value of <span class="math inline">\(x_{i+1}\)</span> substituted in the defining function instead of the current value:</p>
<p><span class="math display">\[
\hat x_{i+1} = \hat x_i + \Delta t \frac {d\hat x_{i+1}}{dt} = \hat x_i + \Delta t f(\hat x_{i+1})
\]</span></p>
<p>How can we calculate the value of <span class="math inline">\(f(\hat x_{i+1})\)</span> if you don’t know <span class="math inline">\(\hat x_{i+1}\)</span>? Depending on the form of <span class="math inline">\(f(x)\)</span>, it may be possible to algebraically solve for <span class="math inline">\(\hat x_{i+1}\)</span>. If we can solve the implicit expression for <span class="math inline">\(y_{i+1}\)</span>, we can program a numeric scheme that will compute the value <span class="math inline">\(\hat x_{i+1}\)</span> directly from <span class="math inline">\(\hat x_i\)</span>. In other situations, the implicit expression may be impossible to solve algebraically. The practitioner may then use a method for solving such an expression numerically, using a numerical root-finding algorithm such as Newton’s method that we will see later in this course.</p>
<div class="callout-tip callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Error in the BE scheme
</div>
</div>
<div class="callout-body-container callout-body">
<p>Here is the implementation of the Backward Euler for the linear ODE <span class="math inline">\(\dot x = a x\)</span>:</p>
<p><span class="math display">\[
\hat x_{i+1} = \hat x_i + \Delta t a \hat x_{i+1}
\]</span></p>
<p>For this particular ODE, the implicit equation can be solved for the future value <span class="math inline">\(\hat x_{i+1}\)</span>:</p>
<p><span class="math display">\[
(1- a\Delta t) \hat x_{i+1} = \hat x_i \Longrightarrow \hat x_{i+1} = \frac{1}{1- a\Delta t} \hat x_i
\]</span></p>
<p>Now we use the same stability analysis as we did for Forward Euler: assume the numerical solution <span class="math inline">\(\hat x_i\)</span> has total error <span class="math inline">\(\epsilon_i\)</span>, and substitute <span class="math inline">\(\hat x_i = x_i + \epsilon_i\)</span>:</p>
<p><span class="math display">\[
\hat x_{i+1} = x_{i+1} + \epsilon_{i+1} = \frac{1}{1- a\Delta t}  (x_i  + \epsilon_i) =  \frac{1}{1- a\Delta t} x_i + \epsilon_i \frac{1}{1- a\Delta t}
\]</span></p>
<p>Again, let us comapare the numeric solution <span class="math inline">\(\hat x\)</span> with the excact solution <span class="math inline">\(x\)</span> and investigate the behavior of the error, which is given by the difference equation:</p>
<p><span class="math display">\[
\epsilon_{i+1} = \frac{1}{1- a\Delta t}   \epsilon_i
\]</span></p>
<p>The error decays with time if the multiplicative constant <span class="math inline">\(1/(1- a\Delta t)\)</span> is less than 1 in absolute value, which can be written as $|1- at| &gt;1 $. We need to consider two cases: positive <span class="math inline">\(a\)</span> and negative <span class="math inline">\(a\)</span>:</p>
<ul>
<li><p>If <span class="math inline">\(a &gt; 0\)</span>, then <span class="math inline">\(|1- a\Delta t|\)</span> is greater than 1 provided that <span class="math inline">\(\Delta t &gt; 1/|a|\)</span>, so the Backward Euler scheme for the exponential growth ODE is stable when <span class="math inline">\(\Delta t\)</span> is greater than a certain threshold. This appears counterintuitive, so it is worth investigating in the lab.</p></li>
<li><p>If <span class="math inline">\(a &lt; 0\)</span>, then <span class="math inline">\(|1- a\Delta t|\)</span> is greater than 1 for any value of <span class="math inline">\(\Delta t\)</span>, so it is <em>unconditionally stable</em>. This is also worth investigating with numeric experimentation.</p></li>
</ul>
</div>
</div>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Necessary imports</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np <span class="co">#package for work with arrays and matrices</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt <span class="co">#package with plotting capabilities</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="implementation-in-python" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="implementation-in-python"><span class="header-section-number">8.1</span> Implementation in Python</h2>
<section id="forward-euler" class="level3" data-number="8.1.1">
<h3 data-number="8.1.1" class="anchored" data-anchor-id="forward-euler"><span class="header-section-number">8.1.1</span> Forward Euler</h3>
<p>We defined the Forward Euler method in the section above, and now we will implement is as a computational algorithm. Like any algorithm, one needs to be clear about its inputs and outputs. In this case, the inputs are the defining function <span class="math inline">\(f(x,t)\)</span>, the initial value, the time step, and the total time. The output is the solution vector <span class="math inline">\(y\)</span>, which contains a sequence of values that approximate the solution of the ODE, along with the vector of time values spaced by the time step. Notice that it is very similar to the script for numeric solution of a difference equation we saw in chapter 1 with the major difference being the presence of a time step, whereas in difference equations the time step is aways 1. There is one more important point for the implementation: usually one needs to solve the ODE for a particular length of time <span class="math inline">\(T\)</span> with a specified time step <span class="math inline">\(\Delta t\)</span> . This dictates that the required number of iterations be <span class="math inline">\(T/\Delta t\)</span>; in other words, for a given time period the number of time steps is inversely proportional to the time step.</p>
<div class="callout-tip callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Outline (pseudocode) for the Forward Euler algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Specify the defining function for the ODE <span class="math inline">\(f(x)\)</span></li>
<li>Set the time step <span class="math inline">\(dt\)</span> and the total length of time <span class="math inline">\(T\)</span></li>
<li>Calculate the number of steps <span class="math inline">\(n \gets T/dt\)</span></li>
<li>Initialize the time array <span class="math inline">\(t\)</span> with <span class="math inline">\(n + 1\)</span> elements</li>
<li>Initialize the solution array <span class="math inline">\(x\)</span> with <span class="math inline">\(n + 1\)</span> elements and initial value <span class="math inline">\(x_0\)</span></li>
<li>Use a for loop to compute the next <span class="math inline">\(x(i+1)\)</span> based on the current <span class="math inline">\(x(i)\)</span> for <span class="math inline">\(n\)</span> steps</li>
</ul>
</div>
</div>
<p>Below we implement the Forward Euler method to solve the linear ODE</p>
<p><span class="math display">\[
dx/dt = r*x
\]</span></p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Implementation of Forward Euler method to solve dx/dt = r*x</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">0.1</span> <span class="co">#set the time step</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">50</span> <span class="co">#set the time duration</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="bu">int</span>(np.ceil(T<span class="op">/</span>dt)) <span class="co">#determine the number of iterations</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.zeros(Niter) <span class="co">#preallocate the solution array</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>P[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">20</span> <span class="co">#set the initial value</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(<span class="dv">0</span>,T,dt) <span class="co">#preallocate the time array</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.5</span> <span class="co">#set the growth rate</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Do the Euler!</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.arange(Niter<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    P[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> P[i] <span class="op">+</span> dt<span class="op">*</span>r<span class="op">*</span>P[i] <span class="co">#this is the FE step</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>plt.plot(t,P)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'time'</span>)  </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'solution'</span>) </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Forward Euler Example'</span>) </span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ch8_numeric_ode_files/figure-html/cell-3-output-1.png" width="576" height="449"></p>
</div>
</div>
<p>The plot should look like an exponential curve, which seems reasonable, but how accurate is it? Remember from the reading that we can define the error of FE at each point, <span class="math inline">\(t\)</span>, as <span class="math inline">\(|x(t)- \hat x(t)|=\epsilon(t)\)</span>. Also, we can define the algorithm as stable if the error at some point, <span class="math inline">\(t\)</span>, does not grow so that <span class="math inline">\(\left|x(t+1)- \hat x(t+1)\right| \leq \epsilon(t)\)</span>, where <span class="math inline">\(x(t)\)</span> is the exact solution.</p>
</section>
<section id="backward-euler" class="level3" data-number="8.1.2">
<h3 data-number="8.1.2" class="anchored" data-anchor-id="backward-euler"><span class="header-section-number">8.1.2</span> Backward Euler</h3>
<p>Now we’ll turn to the second method introduced above, Backward Euler (BE). This time, instead of evaluating <span class="math inline">\(f(x,t)\)</span> at the present time for finding the future point, we use the future point itself! In order to do this, we set up an algebraic relationship between the present value, the future value, and the derivative of the future value such that</p>
<p><span class="math display">\[
\hat x(t+\Delta t) = \hat x(t) + dt*f(\hat x(t+\Delta t)) + \epsilon(t)
\]</span></p>
<p>Then, we must solve for <span class="math inline">\(\hat x(t+\Delta t)\)</span>. Sometimes this will be impossible to do algebraically, but it may be possible to solve the equation numerically. Once we solve for <span class="math inline">\(x(t+1)\)</span>, the steps for implementing the algorithm are similar to the ones for Forward Euler:</p>
<div class="callout-tip callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Outline (pseudocode) for the Backward Euler algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Specify the defining function for the ODE <span class="math inline">\(f(x)\)</span></li>
<li>Set the time step <span class="math inline">\(dt\)</span> and the total length of time <span class="math inline">\(T\)</span></li>
<li>Calculate the number of steps <span class="math inline">\(n \gets T/dt\)</span></li>
<li>Initialize the time array <span class="math inline">\(t\)</span> with <span class="math inline">\(n + 1\)</span> elements</li>
<li>Initialize the solution array <span class="math inline">\(x\)</span> with <span class="math inline">\(n + 1\)</span> elements and initial value <span class="math inline">\(x_0\)</span></li>
<li>Use a for loop to compute the next <span class="math inline">\(x(i+1)\)</span> based on the current <span class="math inline">\(x(i)\)</span> for <span class="math inline">\(n\)</span> steps</li>
</ul>
</div>
</div>
<p>Below is an implementation of the Backward Euler scheme for the generic linear ODE:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Implementation of Backward Euler method to solve dx/dt = r*x</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">0.1</span> <span class="co">#set the time step</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">50</span> <span class="co">#set the time duration</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>Niter <span class="op">=</span> <span class="bu">int</span>(np.ceil(T<span class="op">/</span>dt)) <span class="co">#determine the number of iterations</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.zeros(Niter) <span class="co">#preallocate the solution array</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>x[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2000</span> <span class="co">#set the initial value</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.zeros(Niter) <span class="co">#preallocate the time array</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.5</span> <span class="co">#set the growth rate</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Do the Euler!</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(Niter<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    x[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> x[i]<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>r<span class="op">*</span>dt) <span class="co">#this is the BE step</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    t[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> t[i] <span class="op">+</span> dt <span class="co">#add the current time to the time vector</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.plot(t,x)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'time'</span>)  </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'solution'</span>) </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Backward Euler Example'</span>) </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>plt.show() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ch8_numeric_ode_files/figure-html/cell-4-output-1.png" width="589" height="449"></p>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch7_1var_ode.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Models with one variable in continuous time</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ch9_linear_pplane.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Linear ODEs with two variables</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>